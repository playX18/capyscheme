;; A script to compile psyntax into R5RS code.

(import (capy compiler tree-il)
        (capy compiler tree-il terms)
        (capy compiler tree-il fold)
        (capy pretty-print)
        (capy)
        (scheme base)
        (core lists)
        (scheme process-context))



(define (squeeze-syntax-object syn)
  (define (ensure-list x)
    (if (vector? x)
        (vector->list x)
        x))
  
  (define x (syntax-expression syn))
  (define wrap (syntax-wrap syn))
  (define mod (syntax-module syn))

  (define marks (car wrap))
  (define subst (cdr wrap))

  (define (squeeze-wrap marks subst)
    (make-syntax x (cons marks subst) mod))
  
  (cond 
    [(symbol? x)
      (let loop ((marks marks) (subst subst))
        (cond 
          [(null? subst) (squeeze-wrap marks subst)]
          [(eq? 'shift (car subst)) (loop (cdr marks) (cdr subst))]
          [(find (lambda (entry) (and (eq? x (car entry))
                                      (equal? marks (cadr entry))))
                 (apply map list (map ensure-list (cdr (vector->list (car subst))))))
            => (lambda (entry)
                 (squeeze-wrap marks 
                               (list (list->vector
                                      (cons 'ribcage
                                            (map vector entry))))))]
          [else (loop marks (cdr subst))]))]
    [(or (pair? x) (vector? x)) syn]
    [else x]))

(define (squeeze-constant x)
  (cond 
    [(syntax? x) (squeeze-syntax-object x)]
    [(pair? x)
      (cons (squeeze-constant (car x))
            (squeeze-constant (cdr x)))]
    [(vector? x)
      (list->vector (map squeeze-constant (vector->list x)))]
    [else x]))

(define (squeeze-tree-il x)
  (post-order 
    (lambda (x)
      (if (constant? x)
        (make-constant (term-src x)
                       (squeeze-constant (constant-value x)))
        x))
    x))

(define (translate-literal-syntax-objects x)
  (define (find-make-syntax-lexical-binding x)
    (call/cc 
      (lambda (return)
        (pre-order 
          (lambda (x)
            (when (let? x)
              (for-each (lambda (name sym)
                (when (eq? name 'make-syntax)
                  (return sym)))
                (let-ids x)
                (let-lhs x)))
            x)
          x)
        #f)))
  
  (define make-syntax-gensym (find-make-syntax-lexical-binding x))
  (define retry #f)
  (define (translate-constant x)
    (define src (term-src x))
    (define exp (constant-value x))
    (cond 
      [(list? exp)
        (define exp* (map (lambda (x) (translate-constant (make-constant src x))) exp))
        (if (and-map constant? exp*)
          x 
          (make-primcall src 'list exp*))]
      [(pair? exp)
        (define car* (translate-constant (make-constant src (car exp))))
        (define cdr* (translate-constant (make-constant src (cdr exp))))
        (if (and (constant? car*) (constant? cdr*))
          x 
          (make-primcall src 'cons (list car* cdr*)))]
      [(vector? exp)
        (define exp* (map (lambda (x) (translate-constant (make-constant src x))) (vector->list exp)))
        (if (and-map constant? exp*)
          x 
          (make-primcall src 'vector exp*))]
      [(syntax? exp)
        (make-application src 
          (if make-syntax-gensym 
            (make-lref src 'make-syntax make-syntax-gensym)
            (retry #t))
          (list 
            (translate-constant 
              (make-constant src (syntax-expression exp)))
            (translate-constant
              (make-constant src (syntax-wrap exp)))
            (translate-constant 
              (make-constant src (syntax-module exp)))))]
      [else x]))
      
  (let loop ()
    (define res (call/cc 
      (lambda (return)
        (set! retry return)
        (post-order 
          (lambda (x)
            (if (constant? x)
              (translate-constant x)
              x))
          x))))
    (cond 
      [(boolean? res)
        (translate-literal-syntax-objects 
          (make-toplevel-define 
            (term-src x)
            (toplevel-define-mod x)
            (toplevel-define-name x)
            (make-let 
              (term-src x)
              'let 
              (list 'make-syntax)
              (list (module-gensym))
              (list (make-toplevel-ref #f #f 'make-syntax))
              (toplevel-define-value x))))]
      [else res])))

(define source (list-ref (command-line) 1))
(define target (list-ref (command-line) 2))

(define in (open-input-file source))
(define out (open-output-file target))

;(write '(eval-when (compile) (current-module (resolve-module '(capy) #f #f))) out)
;(newline out)

(write-string ";; Auto-generated by compile-psyntax.scm. Do not edit.\n\n" out)

(let loop ((x (read in)))
  (if (eof-object? x)
    (begin 
      (close-port in)
      (close-port out))
    (begin 
      (pretty-print 
        (tree-il->scheme 
          (translate-literal-syntax-objects 
            (squeeze-tree-il 
              (macroexpand x 'c '(compile load eval))
              '(use-case?)
            )))
        out)
      (newline out)
      (loop (read in)))))

      